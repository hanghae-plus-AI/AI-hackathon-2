title,text,link,sum
"Service와 Repository를 완전히 분리하기 (with. DDD)
","블로그 내비게이션 토글 공지사항 안부 남기기                                                              🚀Architecture       Intro 개발 오픈 톡방에서 ""Service와 Repository는 완벽히 분리되어야 한다.""의 내용이 화두 되었다.
즉, ""도메인은 특정 기술(인프라)에 의존하지 않고 순수하게 유지되어야 한다.""는 말인데,
어떻게 하면 도메인과 인프라를 완벽히 분리할 수 있는지 알아보도록 하자.
  Layered Architecture와 DDD(Domain Driven Design) 레이어드 아키텍처는 가장 흔하게 사용되는 아키텍처이다.
이름 그대로 프로그램 내에서 계층을 나누는 설계 방식이며, 의존의 방향성은 오직 위에서 아래로만 내려간다.
일반적으로 Presentation, Business, Persistence, DataBase의 4개 표준 레이어로 구성한다.
물론 규모에 따라 병합하기도 하며, 그 이상의 레이어로 구성하기도 한다.
 
스프링 기준 대표적인 예시 각 계층은 어플리케이션 내에서 특정 역할과 관심사(화면 표시, 비즈니스 로직 수행, DB 작업 등) 별로 구분되며,
이는 레이어드 아키텍처의 강력한 기능인 '관심사의 분리(Separation of Concern)'를 의미한다.
특정 계층의 구성 요소는 해당 계층의 관련 기능만 수행해야 한다는 것이다.
 
DDD에서 Layered Architecture를 적용하면 아마 다음과 같은 구조가 일반적으로 사용될 것이다. 이제 DDD 관점에서 Repository를 생각해 보자.
우리는 JPA를 사용하는 세대이므로 JPA를 기준으로 글을 작성하겠다. 위 코드는 도메인이 인프라를 의존하고 있어 관심사 분리가 되지 않고 있다.
JpaRepository를 상속받은 인터페이스를 그대로 사용하면서 jpa 메서드가 서비스 도메인에 노출되어 내가 구현하지 않은 메서드를 사용할 수 있고, 반환값으로 엔티티를 받기 때문에 구현 기술에 의존하게 되면서 문제가 생긴다.
 
서비스 도메인은 인프라의 형태에 의존적이지 않아야 한다. 인프라의 구현이 jpa이든 mybatis이든 파일 시스템이든 상관없이 서비스의 구현은 동일해야 한다는 말이다.   구현 기술에 대한 의존 없이 도메인을 순수하게 유지하려면 어떻게 해야 할까? 이 부분은 의존성 역전 원칙(DIP, Dependency Inversion Principle)으로 해결할 수 있다. 현재 도메인 영역이 인프라를 의존하며, 고수준 모듈이 저수준 모듈을 의존하고 있는 것으로 보인다.
이는 반대로 저수준 모듈이 고수준 모듈에 의존하게 해야 한다 라는 의미로,
도메인 → 인프라 의존 관계를 인프라 → 도메인 의존 관계로 의존의 방향을 역전시키겠다는 이야기다. 하지만 한 가지 문제가 생긴다. 코드로 확인해 보자. 위와 같이 도메인에 존재하는 Repository와 인프라에 존재하는 Repository의 형태가 서로 달라져버린다.
그래서 다음과 같이 중간에 Adapter 클래스를 하나 두고, 해당 Adapter가 도메인의 Repository와 인프라의 Repository 사이의 규격을 맞춰주면 된다. DIP를 이용해서 도메인 모델에 존재하는 Repository를 추상화로 만들고 실제 구현을 infrastructure에서 하게 한다. 도메인 관점에서 ""나는 이런 것들을 이렇게 저장할 것이고, 이렇게 불러올 거야!""라는 명세를 만들어놓고 실제 구현 기술에 대한 부분을 분리시킨다는 것이다.
즉, domain layer에서는 저장하는 방법에 대해 관심을 갖고, infrastructure layer 에서는 실제로 어떻게 저장하는지에 대해 관심을 갖는다.
이로써 도메인은 어댑터 뒤에 어떤 기술을 사용하던 상관없이 데이터를 조작하는 데에 필요한 인터페이스만을 바라보고 협력하기 때문에 repository의 형태에 의존하지 않으면서 서비스의 구현은 일관성을 가진다.
 
이렇게 분리하면 복잡성을 낮추고 확장성을 높이는 이점을 취할 수 있다.
하지만 분리하는 것이 마냥 좋은 것만은 아니며, 다음과 같은 몇 가지 문제들이 있다. 너무 많은 컨버팅 코드 휴먼 에러 구현 기술의 강력한 기능 사용 불가   1. 너무 많은 컨버팅 코드 순수 도메인 객체와 영속성 객체는 분리되어야 한다.
즉, service ↔ repository의 파라미터와 반환 값은 외부에 의존적이지 않도록 컨버팅 작업이 필요하다.
만약, 하나의 애그리거트에 매우 많은 중첩 객체가 존재하면 어떻게 될까? ※ 애그리거트는 간략하게 말하자면, 같은 라이프 사이클을 가지는 관련된 객체들을 모아 하나의 단위로 취급하는 개념이다. 일반적으로 DDD에서는 하나의 애그리거트를 repository의 대상 엔티티로 삼는다. Order라는 애그리거트가 존재할 때, 해당 애그리거트를 저장하고 로드하는 repository는 OrderRepository만 존재해야 한다는 소리다. 결국 해당 애그리거트에 포함되는 모든 entity와 value 들에 대해서 transaction consistency를 보장해야 하며, 컨버팅을 하느라 엄청난 시간을 쏟게 된다.
  2. 휴먼 에러 위 컨버팅 문제와 직결된 문제인데, 아래 예시 코드에서 문제점을 찾아보자. 위 코드는 domain의 Order이고, 아래는 infra의 Order이다. Order객체에 address라는 필드가 추가되었는데, 누군가의 실수로 Entity에는 address가 없다.
이는 어쩌면 당연하겠지만 명시적으로 혹은 코드 상에서 domain과 infra의 연결이 분리되었기 때문에 발생하는 문제이다.
이를 컴파일 단에서 확인할 수 없으니 그만큼 안정성은 떨어질 수 있다.
  3. 구현 기술의 강력한 기능 사용 불가 이 역시 컨버팅의 연장선이다.
Lazy Loading이나 Dirty Checking 같은 jpa에서 지원하는 기능은 영속성 계층에 의존하는 기능이다.
따라서 컨버팅 이후 해당 기능들을 사용할 수 없게 된다.   마무리 특정 기술에 의존하지 않는 순수한 도메인 모델 구조를 만들어봤다.
이 구조를 가지면 구현 기술이 변경되더라도 도메인이 받는 영향을 최소화할 수 있다.
하지만 구현 기술이 변경될 일이 잦을까..?🤔
실제로 repository와 도메인 모델의 구현 기술은 거의 변경되지 않는다.
변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과하다고 생각할 수 있다.
물론 프로젝트의 요구사항이나 규모, 자원 등에 따라 다른 판단이 나올 수 있기 때문에 이 부분은 도메인 모델과 구현 기술을 완전히 분리하면서 얻는 이점과 개발 편의성과 실용성을 가져가면서 구조적인 유연함은 유지할 수 있도록 타협을 하는 것 중 선택해야 하는 문제라고 생각한다.
 
 
 
참고 자료 :
오픈 톡방
[DDD] Repository Pattern 이란, 이론편
[DDD] Repository Pattern - 실전편 (Spring 에서 DIP를 통해 Repository의 선언과 구현 분리시키기) Spring Security의 구조(Architecture) 및 처리 과정 알아보기 DDD(Domain-Driven Design) 계층구조(Layered Architecture) 알아보기 슬기로운 개발생활 댓글 8 공유하기 다른 글 안녕하세요. 잘 읽었습니다. 한 가지 의문이 있는데요. 제가 자바를 사용해 보지 않아서 그런것일 수 있지만, 제시해주신 2번 휴먼에러 케이스는 도메인 로직에서 address를 사용하는 로직이 없기때문에 컴파일단에서 아무 문제가 없었던게 아닐까라는 생각이 듭니다. 그래서 조금 적절하지 못한 예시 같다는 생각이 듭니다. 혹시 제가 잘못 지적했다면 죄송합니다.
즐거운개발생활
2024.05.16 10:15
옵션 토글
안녕하세요 :)
address를 infra에 둬서 의도와 다르게 보여진 것 같네요
해당 코드는 수정하겠습니다.
관심 있게 봐주셔서 감사합니다!
coco3o
2024.05.16 13:35
옵션 토글 안녕하세요. 잘 읽었습니다. 한 가지 의문이 있는데요. 제가 자바를 사용해 보지 않아서 그런것일 수 있지만, 제시해주신 2번 휴먼에러 케이스는 도메인 로직에서 address를 사용하는 로직이 없기때문에 컴파일단에서 아무 문제가 없었던게 아닐까라는 생각이 듭니다. 그래서 조금 적절하지 못한 예시 같다는 생각이 듭니다. 혹시 제가 잘못 지적했다면 죄송합니다.	안녕하세요 :)
address를 infra에 둬서 의도와 다르게 보여진 것 같네요
해당 코드는 수정하겠습니다.
관심 있게 봐주셔서 감사합니다!
coco3o
2024.05.16 13:35
옵션 토글 안녕하세요 :)
address를 infra에 둬서 의도와 다르게 보여진 것 같네요
해당 코드는 수정하겠습니다.
관심 있게 봐주셔서 감사합니다!   비밀댓글입니다.
2024.10.08 20:36
옵션 토글
비밀댓글입니다.
2024.10.09 15:14
옵션 토글 비밀댓글입니다.	비밀댓글입니다.
2024.10.09 15:14
옵션 토글 비밀댓글입니다.   비밀댓글입니다.
2024.10.10 17:14
옵션 토글
비밀댓글입니다.
2024.10.11 09:56
옵션 토글 비밀댓글입니다.	비밀댓글입니다.
2024.10.11 09:56
옵션 토글 비밀댓글입니다.   구현기술 변경에 대한 추상화도 있겠지만 도메인 객체들이 테이블 구조를 그대로 따라가는걸 피하려는 것도 있는 것 같아요.
행인
2024.11.14 09:06
옵션 토글
맞습니다~!
저도 도메인 객체는 테이블 구조에 의존하지 않고, 비지니스 로직에 맞게 설계되어야 한다고 생각해요

방문해주셔서 감사합니다 :)
coco3o
2024.11.14 10:48
옵션 토글 구현기술 변경에 대한 추상화도 있겠지만 도메인 객체들이 테이블 구조를 그대로 따라가는걸 피하려는 것도 있는 것 같아요.	맞습니다~!
저도 도메인 객체는 테이블 구조에 의존하지 않고, 비지니스 로직에 맞게 설계되어야 한다고 생각해요

방문해주셔서 감사합니다 :)
coco3o
2024.11.14 10:48
옵션 토글 맞습니다~!
저도 도메인 객체는 테이블 구조에 의존하지 않고, 비지니스 로직에 맞게 설계되어야 한다고 생각해요

방문해주셔서 감사합니다 :)              	구독하기 맨 위로 스크롤하기","https://surfit.io/link/Jmygq
","블로그 내비게이션 토글 공지사항 안부 남기기
개발 오픈 톡방에서 ""Service와 Repository는 완벽히 분리되어야 한다.""는 ""도메인은 특정 기술(인프라)에 의존하지 않고 순수하게 유지되어야 한다. 저수준 모듈이 고수준 모듈에 의존하게 해야 한다 라는 의미로도메인 → 인프라 의존 관계를 인프라 → 도메인 의존 관계로 의존의 방향을 역전시키겠다는 이야기다 Pository만 존재해야 한다는 소리다 2번 휴먼에러 케이스는 도메인 로직에서 address를 사용하는 로직이 없기때문에 컴파일단에서 아무 문제가 없었던게 아닐까라는 생각이 든다. 도메인 객체는 테이블 구조에 의존하지 않고 비지니스 로직에 맞게 설계되어야 한다고 생각해요방문해주셔서 감사합니다 "
"대용량 엑셀 다운로드 OOM(Out Of Memory) 해결 과정
","블로그 내비게이션 토글 공지사항 안부 남기기                                                                    📌ETC/Development Log         	서버가 갑자기 먹통이 된 경험을 했다.
운영 중인 서버의 CPU 사용률이 급격히 상승하며 서버가 죽어버렸다.
서버를 즉시 재가동하고 원인을 확인한 결과, OOM(Out Of Memory)으로 인해 서버가 중단된 것이었다.
  왜 OOM(Out Of Memory)이 발생했는가? 관리자 페이지에서 엑셀 다운로드를 하는데 약 N만 건 이상의 Row를 다운로드하는 과정에 OOM이 발생했다.
현재 운영 중인 서버는 1개의 WAS 안에 서비스, 관리자 등 여러 프로젝트가 함께 돌아가고 있는 상황이다.
여러 요청에 대한 처리와 N만 건 이상의 Row를 다운받는 요청이 겹치면서 과부하가 발생한 것으로 보인다.
하지만, N만 건 정도의 데이터를 처리하면서 OOM이 발생하는 것은 이상하다고 생각하여 원인을 찾아보았다. 원인 파악 현재 엑셀 다운로드를 위해 Apache POI 라이브러리의 XSSFWorkbook을 사용하고 있는데,
문제의 원인은 XSSFWorkbook에서 확인되었다. 메모리 효율성의 부족
XSSFWorkbook 는 엑셀 파일 전체가 만들어질때까지 데이터를 메모리에 상주시키는 방식이다.
큰 데이터셋을 다룰 경우 상당한 양의 메모리를 소비하며, 서버의 메모리 용량에 따라 OOM(Out Of Memory) 에러가 발생할 수 있다. XSSFWorkbook 는 엑셀 파일 전체가 만들어질때까지 데이터를 메모리에 상주시키는 방식이다. 큰 데이터셋을 다룰 경우 상당한 양의 메모리를 소비하며, 서버의 메모리 용량에 따라 OOM(Out Of Memory) 에러가 발생할 수 있다. 대용량 데이터 처리시 성능 저하
작은 데이터셋에서는 문제가 되지 않지만, 수만 또는 수백만 데이터의 대용량 파일을 처리할 때 처리 속도가 현저히 느려지며 성능이 크게 떨어진다. 작은 데이터셋에서는 문제가 되지 않지만, 수만 또는 수백만 데이터의 대용량 파일을 처리할 때 처리 속도가 현저히 느려지며 성능이 크게 떨어진다. 가비지 컬렉션 부담
대용량 파일을 처리하는 동안, XSSFWorkbook은 많은 수의 임시 객체를 생성할 수 있다.
이는 가비지 컬렉터에 부담을 주며, 시스템의 전체 성능에 영향을 줄 수 있다. 대용량 파일을 처리하는 동안, XSSFWorkbook은 많은 수의 임시 객체를 생성할 수 있다. 이는 가비지 컬렉터에 부담을 주며, 시스템의 전체 성능에 영향을 줄 수 있다.   문제 해결 방법 사실 이 방법이 제일 쉬운 방법이다.
OOM이 발생한 가장 직관적인 이유는 메모리가 부족한 것이다. 현재 운영 중인 서버의 메모리는 8GB 밖에 되지 않는다...😂 서버의 메모리를 증설하여 스케일업 하면 해결될 일이다.
하지만, 데이터가 계속 증가할 것을 고려하면 메모리 증설만으로는 근본적인 해결책이 될 수 없다.
  현재 운영 중인 서버는 하나의 톰캣 서버에 여러 프로젝트가 돌아가고 있는 One To Many 구조이다.
이 프로젝트들을 각각 독립된 서버로 분리하는 방법도 고려해 봤지만,
서버 비용과 들어갈 작업의 양이 많아 당장 진행하기엔 어려움이 있었다..
  한정된 내부 자원 안에서 해결할 수 있는 방법이 없을까 고민하였고,
엑셀 다운로드를 지원하는 Apache POI 라이브러리 중 SXSSFWorkbook를 찾을 수 있었다.
 
SXSSFWorkbook은 지정한 Row만큼만 메모리에 로드하여 처리하다가 지정한 Row에 도달하면
임시 XML 파일로 디스크에 기록하고 메모리를 비워주는 스트리밍 방식이다.
즉, SXSSFWorkbook은 메모리에 있는 데이터를 디스크로 옮기면서 처리하기 때문에 메모리를 적게 먹어 대용량 데이터 처리에 매우 적합하다.

비록 디스크에 플러시한 Row는 다시 접근 할 수 없는 단점도 있지만, 현재 상황에서는 큰 문제가 되지 않았다. 아래와 같이 인자 값을 지정해주면 설정한 row 수만큼 작성 후 알아서 flush 해준다.🙂 아래와 같이 flushRows 메서드로 데이터를 수동으로 디스크로 옮길 수도 있다.  작업 완료 후엔 디스크에 저장된 임시파일을 삭제해줘야 한다.

 XSSFWorkbook을 SXSSFWorkbook 라이브러리로 사용하도록 변경했다. 개선 전후 비교하기 로컬에서 약 10만 건의 데이터를 추출하는 API를 10회 연속으로 호출하는 테스트를 진행했으며,
VisualVM을 사용해 메모리 변화를 모니터링했다.   개선 전에는 요청을 처리하다가 서버가 죽었고, 개선 후에는 서버가 안정적으로 작업을 처리했다.
메모리 사용량 그래프도 전과 비교하면 상당히 안정적이며 기존보다 약 80%정도 절감되었다. 😀
메모리 효율성이 향상되면서 다운로드 속도도 크게 개선됐으며,
10만 건의 데이터를 다운로드하는 데 77초에서 5초로 단축되어, 약 1400% 이상 성능이 개선되었다.🔥
 

라이브러리를 변경하면서 엑셀 다운로드 코드 베이스 구조의 문제점도 몇 가지 보여 나중에 전반적으로 개선 후 다시 블로그에 정리해야겠다. [Java] Apache POI 엑셀 다운로드 간단한 모듈화로 쉽게 사용하기 DTO Inner Class로 한번에 관리하기 Spring Boot JPA 게시판 댓글 작성자만 수정, 삭제 가능하게 하기 Spring Boot JPA 게시판 댓글 수정 및 삭제 구현하기 Spring Boot JPA 게시판 댓글 작성 및 조회 구현하기 슬기로운 개발생활 댓글 3 공유하기 다른 글 스크롤이 아래로 안 내려가져요.. Disable JavaScript 껐다 키면서 댓글 남깁니다...
안녕하세요
2024.08.18 13:15
옵션 토글 스크롤이 아래로 안 내려가져요.. Disable JavaScript 껐다 키면서 댓글 남깁니다...	주인장님 항상 존경합니다. 얼마안된 신입개발자지만 곧 오픈하는 서버인데 테스트만으로 서버 죽는 게 제일 고통스럽더라구요,,
코귤
2024.10.13 20:58
옵션 토글
아이고 좋게 봐주셔서 감사합니다 ㅎㅎ
맞아요 특히 운영 중인 서버가 죽어버리면.. 어후,,
coco3o
2024.10.15 10:27
옵션 토글 주인장님 항상 존경합니다. 얼마안된 신입개발자지만 곧 오픈하는 서버인데 테스트만으로 서버 죽는 게 제일 고통스럽더라구요,,	아이고 좋게 봐주셔서 감사합니다 ㅎㅎ
맞아요 특히 운영 중인 서버가 죽어버리면.. 어후,,
coco3o
2024.10.15 10:27
옵션 토글 아이고 좋게 봐주셔서 감사합니다 ㅎㅎ
맞아요 특히 운영 중인 서버가 죽어버리면.. 어후,,                	구독하기 맨 위로 스크롤하기","https://surfit.io/link/p4blm
",엑셀 다운로드를 위해라이브러리의 XSSFWorkbook을 사용하고 있는데 문제의 원인은 XSSFWorkbook에서 확인되었다 서버의 증설만으로는 근본적인 해결책이 될 수 없다 엑셀 다운로드 간단한 모듈화로 쉽게 사용하기Class로 한번에 관리하기게시판 댓글 작성자만 수정삭제 가능하게 하기게시판 댓글 수정 및 삭제 구현하기 댓글공유하기 다른 글 스크롤이 아래로 안 내려가져요껐다 키면서 댓글 남깁니다. 
"콘텐츠를 조립하는 결제탭 피드 서버의 코드 아키텍처
","요약: 이 글은 결제탭 서버의 Server Driven UI(SDU) 방식을 설명하며, 안정적이고 유연한 구조로 결제탭의 다양한 콘텐츠를 효율적으로 서빙하는 방식을 다룹니다. 결제탭은 MSA 구조와 비동기 API 호출을 활용해 사용자 맞춤형 혜택과 기능을 제공하며, Row 설정을 통해 각 UI 요소를 동적으로 관리합니다. 또한, 서버가 다운되거나 예외 상황이 발생하더라도 안정성을 유지하기 위해 Result와 3중화 캐싱 기법을 사용하여 피드 데이터의 무결성을 보장합니다. 💡 리뷰어 한줄평 larry.charry 유연함과 안정성 두 마리 토끼를 잡기 위해 많은 고민을 녹여주셨네요. 아름다운 코드 아키텍처와 서비스 무중단을 위해 파일까지 관리하는 모습이 인상적이었습니다. daisy.dani 결제탭의 다양한 콘텐츠를 빠르고 안정적으로 서빙하기 위해 어떤 기법을 적용했을까요? 해피와 함께 이 글에서 확인해 보시죠! rain.drop 외부 연동 데이터를 어떻게 하면 재사용할 수 있을지, 개발 생산성까지 고려한 설계에 대해 여러 고민과 적용이 잘 드러나는 글이에요! 어떻게 아키텍처를 설계하고 개발 생산성을 향상했는지 함께 들여다봐요~ 시작하며 안녕하세요. 채널서버유닛에서 결제탭 서버를 개발하고 있는 해피입니다. 결제 콘텐츠 피드인 결제탭 개발 과정에서, 변칙적인 요구사항을 만족하는 코드 아키텍처를 개발하기 위한 접근 방식에 대해 이야기해 보려고 합니다. 결제탭은 결제와 관련된 다양한 혜택과 편의 기능을 제공하는 피드입니다. 사용자들에게 결제 중심으로 다양한 혜택을 보여주기 위해 만들어졌습니다. 사용자에게 맞춤 혜택과 멤버십 쿠폰 등을 추천하고, 위치 기반으로 당장 사용할 수 있는 혜택을 제공합니다.   이렇게 사용자 중심으로 다양한 콘텐츠를 제공하는 피드 서비스는 어떤 구조로 개발되어 있을까요? 이 글에서는 결제탭에서 Server Driven으로 다양한 데이터를 서빙하기 위해 적용한 코드 아키텍처와 안정성을 위한 다양한 기법들을 소개하겠습니다. 여러 마이크로 서비스를 호출해 콘텐츠를 서빙하는 피드를 개발하거나, 코드 아키텍처에 관심 있는 분들에게 흥미로운 내용이 될 것 같습니다. 크게 3가지로 나눠서 살펴보겠습니다. 결제탭과 Server Driven UI Server Driven UI에 대응하기 위한 코드 아키텍처 안정적인 피드를 위한 기법 결제탭과 Server Driven UI 결제탭은 BFF(Backend For Frontend) 입니다. BFF는 클라이언트가 화면을 그릴 때 필요로 하는 모든 데이터를 제공하기 위해, 마이크로 서비스 호출을 대신하고 응답을 하나로 만들어서 내려줍니다. 클라이언트가 퍼블릭 인터넷 환경에서 여러 개의 API를 호출해 조합하는 것보다 서버가 애플리케이션 네트워크 망 내 고속 네트워크 환경에서 여러 마이크로 서비스를 호출해 하나의 응답으로 만들어주는 게 훨씬 응답 속도 관점에서 유리하기 때문입니다. 또한, 클라이언트는 데이터 조합 대신 서버와 확정한 데이터 모델을 통해 UI 구현에 집중할 수 있습니다. 자세한 내용은 WebFlux와 코루틴으로 BFF 구현하기에서 보실 수 있습니다. 결제탭은 카카오페이 앱을 실행했을 때 처음에 보이는 화면입니다. 첫 화면에서는 빠른 렌더링이 중요하기 때문에 결제탭에서는 네이티브 UI를 사용합니다. 네이티브는 웹뷰와 달리, 앱 심사와 배포 과정으로 인해 최신 UI 변경사항이 즉시 반영되지 않습니다. 따라서 사용자가 앱을 업데이트하기 전까지 오래된 UI와 기능이 유지됩니다. 이 문제를 해결하기 위해 카카오페이 클라이언트 실에서 Server Driven UI(이하 SDU) 라는 시스템을 만들었고, 이를 통해 네이티브에 즉시적인 UI 변경을 반영할 수 있게 되었습니다. SDU 어드민에서 각 UI에 대한 구성과 라벨 등을 설정하여 배포하면, UI 갱신 시에 변경이 바로 반영됩니다. 한편, 커스텀한 애니메이션이 들어가거나 데이터의 양에 따라 UI가 완전히 달라지는 경우 등에서는 클라이언트에서 직접 UI를 구현해야 합니다. 광고 지면의 경우 광고 SDK를 사용해야 하는 부분도 있습니다. 결제탭은 피드에서 보이는 아이템들을 Row라고 부릅니다. 각 Row의 RenderType은 SDU, NATIVE, AD 3가지로 나뉩니다. SDU: SDU SDK를 통해 UI를 렌더링 NATIVE: 결제탭에서만 UI를 커스텀하게 렌더링 AD: 광고 SDK를 통해 UI를 렌더링   결제탭 서버는 UI 중심의 응답 구조를 가지며, 클라이언트가 주고받는 데이터 모델인 Row 규격은 다음과 같습니다. 각 Row는 고유 식별자인 rowId를 가지고, 앞서 보았듯이 UI 표현에 대한 구분을 RowType으로 하게 됩니다. data는 UI를 구현하는데 필요한 데이터이고, meta에는 지표 수집을 위한 데이터 또는 기타 설정들이 포함됩니다. 결제탭 서버에서는 사용자 피드를 구성하기 위해 속성과 정책을 RowSetting이라는 정보로 DB에 저장합니다. 이로써 운영자가 필요에 맞게 어드민에서 설정을 즉시적으로 조정할 수 있습니다. 	앞서 결제탭과 Server Driven UI의 개념과 필요성을 살펴보았습니다. 결제탭은 SDU를 사용해 즉시적인 UI 변경을 반영하고, 어드민 설정을 기반으로 동적으로 피드 데이터를 조합해 응답합니다. 지금부터 동적으로 동작하는 결제탭 서버의 내부 코드 아키텍처가 어떻게 구성되어 있는지 살펴보겠습니다. 연동과 Row의 N:M을 지원하는 코드 아키텍처 결제탭은 논블록킹으로 클라이언트에 응답을 빠르게 전달하기 위해, 기술 스택으로 Kotlin, Spring, Webflux를 사용하고 DB는 R2dbc를 사용합니다.   먼저 결제탭을 단순화한 버전을 가지고, 구현 방식에 대해 pseudo 코드로 접근해 보겠습니다. 외부 마이크로 서비스인 혜택, 쿠폰 서버를 호출해 필요한 데이터를 가져오고 이걸 하나의 응답으로 만들어줘야 합니다. (API 조회 또는 DB 질의 등 외부 시스템을 호출하는 경우를 연동이라고 포괄하여 표현하겠습니다) 혜택 서버를 호출하여 결제탭 Row 응답을 만드는 BenefitService 컴포넌트를 선언하고, 쿠폰에 대한 Row 응답을 만드는 CouponService 컴포넌트도 선언합니다. 코루틴 async 빌더를 사용하여 각 서비스를 비동기로 호출하고, 결과를 받아서 하나의 응답으로 만들어줍니다. 결제탭은 DB에 저장된 피드 정보인 RowSetting을 기반으로 동적으로 Row를 생성해야 합니다. RowSetting 기반으로 동작하도록 앞선 코드를 수정합니다. RowSetting에 대해 필요한 연동 데이터를 가져와 응답을 생성하는 과정인 process 로직을 수행하도록 변경했습니다. 아까 각각 호출했던 benefitService.createRow()와 couponService.createRow() 로직이 process에 해당됩니다. RowType에 대한 process를 수행할 Processor를 정의하면 설정에 따라 필요한 데이터만 응답으로 만들어서 내려줄 수 있습니다. “Row의 속성에 따라 필요한 데이터를 불러오고, 응답에 필요한 형태로 변환한다” 구조로 만들 수 있습니다. 하지만 결제탭에서는 좀 더 복잡한 요구사항이 있었기에, 이를 대응하기 위한 코드 아키텍처로 변경되었습니다. 결제탭에서 사용된 연동되는 데이터와 Row의 관계에 대한 경우의 수는 다음과 같습니다. 1. 한 연동에서 가져온 데이터를 한 Row에서 사용 = 1:1   결제탭에서 결제팁 테이블에 저장된 데이터들을 가져와 하나의 Row로 보여주는 요구사항입니다. 가장 일반적인 요구사항으로, 이러한 방식만 존재한다면 위에 소개드렸던 process 처리로도 충분합니다. 2. 여러 연동에서 가져온 데이터를 한 Row에서 사용 = N:1   5초마다 결제내역과 받은 혜택이라는 2가지의 데이터를 롤링하는 카드인데요. 이를 위해 서버에서 2개의 API를 호출한 내용을 하나의 Row로 합쳐 응답해야 합니다. 여러 개의 API를 사용하더라도 그걸 하나의 컴포넌트에서 실행되도록 만들면 되기 때문에 1:1 맵핑과 동일하게 처리할 수 있습니다. 코드 아키텍처의 변경을 야기한 사항은 다음의 경우였습니다. 3. 이미 카드에 쓰였던 연동에서 가져온 데이터를 다른 Row에 재활용 = N:M   위 이미지 속 3개의 Row인 내 쿠폰, 퀵 버튼, 멤버십에서 각기 쿠폰조회 API와 멤버십 조회 API를 중복하여 사용하게 되는데요. 이미 콘텐츠를 만드는 데 사용되었던 연동 데이터를 또 다른 곳에 사용해야 하는 경우가 발생합니다. process 구조를 유지한다면 동일한 연동 데이터를 2번 호출할 수밖에 없습니다. 결제탭 화면은 페이앱의 첫 화면의 트래픽을 받는데, 이를 연동한 마이크로 서비스에 2배의 부하를 전달하게 할 수는 없습니다. 코드 아키텍처의 변화가 필요합니다. 기존 구조에서 문제였던 것은 연동에서 가져온 데이터와 응답으로 만드는 로직이 process라는 하나의 단계로만 진행되었다는 점입니다. 연동된 데이터를 가져오는 부분과 응답을 생성하는 부분을 분리하면 문제를 해결할 수 있습니다. Provider, Consumer, Aggregator 앞선 pseudo 코드에서는 연동과 응답 생성 두 가지가 하나의 Processor에 담겨있었습니다. 요구사항이 복잡해짐에 따라 이들의 관계가 1:1이 아니므로 Processor를 더 작은 단위로 나눕니다. 연동 데이터를 가져오는 컴포넌트들을 Provider로, 데이터를 기반으로 카드 응답을 만드는 컴포넌트를 Consumer로 분리합니다. 각각의 Provider와 Consumer를 적절하게 맵핑하고 조합해 주는 역할이 필요한데, 이를 Aggregator로 정의합니다.   Provider: 외부로부터 연동 데이터를 가져오는 컴포넌트 Consumer: 연동 데이터(들)를 기반으로 UI로 표현할 응답을 만드는 컴포넌트 Aggregator: 두 컴포넌트가 중복 호출 없이 비동기로 동작할 수 있도록 중계해 주는 컴포넌트 Provider는 API나 DB로부터 데이터를 가져오는데 집중하고, Consumer는 데이터로부터 응답으로 반환할 Row를 만드는 데 집중합니다. Aggregator는 두 개의 컴포넌트 사이를 중계하며, 비동기로 Provider를 실행시켜 가져온 데이터를 Consumer로 넘겨주는 역할을 합니다.   이전 pseudo 코드에서 RowType에 대해 process 동작을 수행했던 것을 provide, consume 과정으로 분리합니다. 따라서 내부적으로 처리하는 타입도 ProviderType과 ConsumerType으로 각각 분리되어야 합니다. consume 하여 Row를 만들어 내고, 클라이언트에게 RowType으로 UI 종류를 전달하기 때문에, ConsumerType 이름보단 RowType을 사용합니다. 이제 연동과 Row를 맵핑할 타입이 필요합니다. ProviderType과 RowType을 맵핑할 타입으로 RowProviderType를 정의합니다. DB에 저장되는 RowSetting이 각 RowProviderType을 컬럼으로 가집니다. 이러한 맵핑 정보는 enum으로 관리하게 됩니다. ProviderType에는 연동 포인트의 종류가 정의되고, RowType에서는 어떤 UI 데이터로 렌더링 해야 하는지 정의됩니다. RowProviderType에서 ProviderType와 RowType을 통해 연동과 Row를 맵핑합니다. 이렇게 연동과 UI별로 구분된 타입들은 로직 실행 시 컴포넌트를 트리거하는 구분점으로 동작합니다. Aggregator RowType에 따라 하나로 묶여 수행되던 process 과정을 ProviderType과 RowType으로 분리하여 provide, consume으로 동작할 수 있도록 기반을 마련했습니다. 이제는 이 분리된 과정들이 피드 조회 요청 시 하나로 묶여 비동기로 동작하도록 Aggregator를 만드는 과정이 필요합니다. 각각의 provide 결과를 하나로 합치고, 필요한 곳에서 consume 하는 과정이 필요한데요, 이 과정을 aggregate에서 수행합니다. 새로운 pseudo 코드에서 DB에 저장된 피드 정보인 RowSetting을 기반으로, RowProviderType에 따라 Provider가 수행되고, RowType에 따라 Consumer가 수행됩니다. ProviderType에 따라 Provider를 맵핑해 주는 부분과 RowType과 Consumer 구현체를 연결해 주는 부분이 필요한데, 그 부분은 실제 코드 구현에서 살펴보겠습니다. provide는 여러 연동 포인트를 호출하는 로직이기 때문에 비동기 코루틴 빌더를 통해 실행되도록 합니다. 연동 포인트로부터 모든 데이터를 받을 때까지 최대 Read Timeout 만큼의 시간이 소요됩니다. Timeout 내 응답을 받지 못한 연동 포인트들은 버립니다. 꼬리 지연 시간을 줄이고, 사용성을 위해서 버림이 필요합니다. consume은 results와 RowSetting을 통해 Row 응답을 생성합니다. 에러나 Timeout 등으로 결과가 없는 경우는 Row를 생성하지 않거나 에러일 때 보여줄 UI 응답을 내려줍니다. consume 과정은 데이터 객체를 응답 객체로 변환하는 과정이므로 비동기 로직이 필요 없습니다. 이제는 provide, consume, aggregate를 각 구현체인 Provider, Consumer, Aggregator로 만들고, 실제 코드를 수준으로 살펴보겠습니다. 실제 코드 구현 Provider에서 연동으로부터 결과를 얻는 것으로 시작해서, Consumer에서 그 결과로 응답을 만들어 내는 코드, 이 두 가지를 연결하는 Aggregator 코드 순으로 살펴보겠습니다. Provider 인터페이스 Provider 구현체는 ResultProvider 인터페이스를 구현해야 합니다. Provider 구현체 멤버십 API를 호출하여 결과를 가져오는 ResultProvider의 구현체인 MembershipProvider의 코드입니다. 이런 식으로 새로운 연동이 필요한 경우 ResultProvider 구현체를 생성하게 됩니다. ResultProviderMapper: ProviderType과 Provider 구현체 맵핑 ResultProviderMapper에서는 피드의 설정인 RowSetting에 해당하는 Provider를 매칭해 줍니다. 각 연동 구현체들이 ResultProvider 인터페이스를 구현하고, 이 구현체들이 주입되기 때문에 getResult 함수에서는 각 구현체들의 getResult를 호출해 줍니다. ProviderType에 대한 구현체들이 모두 존재하는 걸 보장하기 위해, init 단계에서 resultProviderCompoments가 모든 ProviterType를 가지는 지 확인하고 예외를 던져줍니다. 만일 개발자가 실수로 구현체 없이 새로운 ProviderType만 추가한다면 애플리케이션 start 시에 에러가 발생합니다. Consumer 구현체 MembershipResultConsumer는 연동 데이터를 가져와서 응답에 필요한 Row 형태로 생성해 줍니다. ResultConsumerMapper: RowType과 Consumer 구현체 맵핑 ResultProviderMapper처럼 각각의 ResultConsumer에 데이터 넣어 맵핑해 주는 과정이 필요한데요. ResultConsumer는 bean이 아닌 object로 만들었기 때문에, 각 RowType에 직접 맵핑해 주는 로직이 필요합니다. 연동 데이터를 다른 객체로 변환해 주는 단순한 역할이라 object를 사용했습니다. Provider와 달리 Consumer는 method signature가 달라 interface로 묶어서 주입할 수 없다는 이유 때문이기도 합니다. 각 Consumer를 호출할 때, 모든 연동 데이터가 모여있는 resultMap: Map<ProviderType, Result<Any?>> 필요한 파라미터를 전달해 줍니다. 예시의 멤버십 데이터는 MembershipwResultConsumer에서도 사용되고, QuickButtonResultConsumer에서도 인자로 들어가는데요. 두 가지에서 동시에 사용됩니다. Aggregator FeedAggregator는 피드 설정인 RowSetting에 따라 ResultProviderMapper사용해 비동기로 데이터를 호출해 조합하고, 그 데이터를 ResultConsumerMapper를 사용해 응답으로 변환하는 중계 컴포넌트입니다. 결과적으로 코드의 구조는 다음과 같습니다.   FeedAggregator가 RowSettings에 정의된 RowType의 ProviderType에 대한 ResultProvider들을 가져오기 위해 ResultProviderMapper가 사용됩니다. 마찬가지로 ResultConsumerMapper를 통해 ResultConsumer에 접근합니다. 결과적으로 FeedAggregator를 통해 여러 ResultProvider로부터 비동기로 가져온 Result<T> 연동 데이터는 ResultConsumer로 전달됩니다. 이렇게 컴포넌트를 분리하면 변경에 영향받는 범위가 작아집니다. 신규 연동이 필요한 경우   신규 연동이 있을 때는 ResultProvider 영역만 변경하면 됩니다. 신규 UI가 추가된 경우   신규 UI 타입이 발생하면 ResultConsumer 영역만 변경되면 됩니다. 최종적으로 변경이 발생하는 영역   ResultProviderMapper에서는 Spring DI(Dependency Injection)을 통해 ResultProvider를 주입받으므로 최종적으로 다음의 영역만이 새로운 기능 추가 시 변경됩니다. Selector 기법 앞선 N:M 맵핑에서 설명하지 않았던 케이스가 하나 있는데요. 하나의 연동에서 가져온 데이터를 여러 Row에서 사용하는 경우인 1:N 맵핑입니다. 4. 하나의 연동에서 가져온 데이터를 여러 Row에서 사용 = 1:N   하나의 연동에서 벌크로 가져온 데이터를 여러 Row에서 사용하는 경우가 있습니다. 이때에도 연동이 재활용되어야 함은 물론이고, 한 연동을 여러 Row에서 재활용할 때 각자 어떤 데이터를 가져다 써야 할 지에 대한 정보가 필요합니다. 이를 해결하기 위해 적용한 기법은 Selector라는 개념입니다.   Row에 필요한 Selector의 값은 어드민에 설정해 두기 때문에, DB에 저장된 피드 정보인 RowSetting이 Selector 컬럼을 가지고 있습니다. 각각의 배너광고 RowSettings의 Provider는 광고 Slot API를 호출하는 AD_BULK Provider입니다. Aggregator에서 비동기로 다른 연동과 함께 AD_BULK의 연동도 가지고 오게 됩니다.   이 값은 BannerConsumer로 넘겨지는데요. 각 BannerConsumer에서 동일한 연동값인 API Response가 전달됩니다. 이 중 자신에게 해당되는 값이 저장된 Selector의 slotMatch 값과 API Response에 있는 필드인 slot_name을 비교하여 자신에게 해당되는 값을 식별하게 됩니다. 단순하게는 위 예시처럼 광고 slot name이 일치하는지 확인하는 selector가 있고, 데이터의 순서를 선택하는 indexMatch, 모듈러 연산으로 랜덤을 선택하는 randomModuloRule, 국가 코드 일치를 확인하는 countryMatch 등 다양한 기능이 있습니다. Selector는 json 컬럼으로 관리하기 때문에 Selector 객체에 넣은 다양한 기능을 복합적으로 설정하고 사용할 수 있습니다. 안정적인 피드를 위한 기법 kotlin.Result 안정성을 중요시하는 것은 당연하지만, 결제탭은 카카오페이 앱의 첫 화면이기 때문에 예외 핸들링을 더욱 철저하게 해야 합니다. 결제탭에서는 Result를 활용하여 에러 발생 구간을 명시적으로 처리합니다. 실패가 발생할 수 있는 데이터를 Result로 감싸서 사용합니다. Result를 사용하면 Success, Failure인 경우를 명시적으로 처리할 수 있기 때문에 의도적으로 실패인 경우를 처리할 수 있습니다. 특히 연동이 실패한 경우, Failure를 핸들링하여 디폴트 콘텐츠를 보여주거나 제거하는 등 명시적으로 코드를 작성할 수 있습니다. 결제탭은 API를 호출하거나 DB, Redis에 액세스 하는 등 예외가 발생할 수 있는 부분을 처리하는 로직은 runCatching을 통해 감싸 Result으로 반환해 사용합니다. Consumer에서 Result<T>로 받아, Failure일 때 빈 응답을 반환할지, 디폴트 콘텐츠를 보여줄지 결정할 수 있습니다. 외부 통신으로 인해 실패가 발생할 수 있는 부분을 명시적으로 Result로 감싸 처리하면, 성공과 실패에 대한 처리가 명확해지기 때문에 코드 안정성이 더욱 증가합니다. DB, 캐시, 리소스 3중화 결제탭은 DB에 저장된 RowSetting 정보를 기반으로 동작하기 때문에, 장애 시에도 이 데이터를 안전하게 확보하는 것이 중요합니다. 이를 위해 DB에서 가져온 RowSetting을 Redis에 캐싱해 사용하고 있습니다. 또한 Redis 캐시를 갱신하는 시점에 DB에 접근할 수 없거나 Redis 장애로 캐시를 사용할 수 없는 경우를 대비해, 최소한의 Row들만을 정의한 row_setting_backup.json 파일을 코드 내 리소스 파일로 관리하고 있습니다. DB, Redis에 장애가 발생했을 때, 최소한 결제탭 서버만이라도 살아있다면 피드를 서빙할 수 있습니다.   기본적으로 API와 DB에서 모든 유저에게 동일하게 보이는 데이터의 경우 Redis 캐시를 사용하고 있습니다. 응답시간을 단축하고, 사용하는 마이크로 서비스에 트래픽 부담을 줄일 수 있습니다.   결제탭 서버는 다운되지 않은 이상, 앞서 언급한 여러 기법을 사용하여 안정성을 보장하고 있습니다. 그러나, 서버가 다운되거나, 응답 지연으로 클라이언트에서 응답을 받을 수 없는 경우에는 클라이언트 자체에 캐싱된 데이터를 보여줍니다. 클라이언트에서는 서버로부터 응답을 받기 전까지 기존 피드 데이터를 보여주고, 응답을 받았을 때 피드를 갱신합니다. 이렇게 되면 서버 장애 상황에서도 피드 콘텐츠를 보여줄 수 있습니다. 한편, 각 Row에는 만료 시간도 포함되어 있어 만료된 데이터는 캐시 데이터에서 제외하고 보여줍니다. 이로써 만료된 콘텐츠가 유저에게 보일 위험성도 없습니다. 마치며 서비스가 고도화될수록 개발 비용이 줄어드는 것이 이상적입니다. 특히, 외부 콘텐츠를 제공하는 피드 서비스에서는 새로운 기능을 추가하기보다는 다양한 콘텐츠를 쉽게 확장할 수 있도록 시스템을 설계하는 게 중요합니다. 시스템을 잘 설계하면, 서비스 유지보수 비용을 줄이면서 사용자에게 다양한 콘텐츠를 지속적으로 제공할 수 있습니다. 현재의 코드 아키텍처에서 새로운 콘텐츠가 필요할 때, Consumer만 하나 추가하고 SDU를 사용해 사용자에게 새로운 콘텐츠를 바로 제공할 수 있습니다. 이 아키텍처 덕분에 새 요구사항이 들어왔을 때 들어가는 개발 비용이 크게 감소했습니다. 개발 생산성이 향상되었고, 유저에게 새로운 콘텐츠를 더 빨리 제공할 수 있게 되었습니다.   지금도 결제탭에 다양한 요구사항이 발생하고 있는데요, 현재의 코드 아키텍처로도 유연하게 대응할 수 있어서 뿌듯함을 느낄 때가 많습니다. 현재의 코드 아키텍처는 지금은 맞고, 나중엔 틀릴 수 있습니다. Processor를 Provider, Consumer, Aggregator로 나눴던 것처럼 예측하지 못한 변경이 발생하면, 새로운 구조를 만들어내야 합니다. 가장 중요한 것은 계속해서 유연한 구조로 변화해 가는 것입니다. 현재의 구조에서 불가한 것은 무엇이고, 어떤 부분이 문제인지 찾아서 수정하는 과정이 개발자에게 참 중요한 것 같습니다. 저는 이 과정을 즐기는데요, 여러분도 담당 서비스에서 개선할 부분을 찾아 최적화하는 재미를 함께 느껴보셨으면 좋겠습니다. 카카오페이에서 백엔드 개발을 하고 있는 해피입니다. 개발만큼 자기 개발을 좋아합니다. BE MSA BFF Kotlin Code Architecture            	#BE
주니어 서버 개발자가 유저향 서비스를 개발하며 마주쳤던 이슈와 해결 방안
2024. 11. 5
카카오페이 #BE
URL이 이상해요! Java와 Spring 중 범인은 누구?
2024. 9. 26
카카오페이 #BE
코틀린, 저는 이렇게 쓰고 있습니다
2024. 9. 12
카카오페이 #BE
쓰기만 했던 개발자가 궁금해서 찾아본 쿠버네티스 내부 2편
2024. 9. 3
카카오페이 #BE
쓰기만 했던 개발자가 궁금해서 찾아본 쿠버네티스 내부 1편
2024. 8. 20
카카오페이 #테스트 코드
실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 3: Given 지옥에서 벗어나기 - 객체 기반 데이터 셋업의 한계
2024. 8. 14
카카오페이 #BE
[Project Loom] Virtual Thread에 봄(Spring)은 왔는가
2024. 7. 24
카카오페이 #BE
마이데이터 플랫폼의 대용량 데이터 처리 개선! 구경 한번 해볼래?
2024. 7. 10
카카오페이 #google cloud next
Google Cloud Next 2024 참관 후기 4편 - AI를 장착한 개발자의 파워풀한 퍼포먼스 내기
2024. 7. 2
카카오페이 #google cloud next
Google Cloud Next 2024 참관 후기 2편 - Google Cloud Serverless for Java developer
2024. 6. 18
카카오페이 #BE
R2DBC Connection Pool 실종 사건
2024. 6. 11
카카오페이 #BE
여러 제휴사와 연동하는 신규 프로젝트 개발기 2편
2024. 4. 3
카카오페이 #BE
여러 제휴사와 연동하는 신규 프로젝트 개발기 1편
2024. 4. 3
카카오페이 #BE
실전에서 TDD하기
2024. 1. 23
카카오페이 #BE
Spring 공화국에서 Ktor 사용하기
2024. 1. 11
카카오페이 #BE
MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략
2023. 12. 12
카카오페이 #BE
카카오페이 온라인 결제 서비스 2.5배 성능 개선기
2023. 12. 7
카카오페이 #BE
자바 프로젝트 3개 코틀린 점진적 전환기(feat. lombok 됩니다.)
2023. 12. 5
카카오페이 #BE
멀고도 험난했던 개발 지원이 중단된 Library 연동 과정
2023. 10. 24
카카오페이 #BE
Spring Batch 애플리케이션 성능 향상을 위한 주요 팁
2023. 9. 5
카카오페이 #테스트 코드
실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 2: 테스트 코드로부터 피드백 받기
2023. 8. 28
카카오페이 #BE
Kotlin으로 Spring AOP 극복하기!
2023. 8. 16
카카오페이 #BE
카카오페이만의 AB 테스트 서비스를 만든 이유
2023. 8. 11
카카오페이 #테스트 코드
실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 1: 효율적인 Mock Test
2023. 7. 10
카카오페이 #BE
Spring Bean Injection 이야기(feat. 모두가 다 알고 있는 스프링빈, 정말 다 알고 있는가?)
2023. 5. 31
카카오페이 #BE
Spring 기반 OAuth 2.1 Authorization Server 개발 찍먹해보기
2023. 5. 22
카카오페이 #이벤트 드리븐
이벤트 드리븐 적재적소에 사용하기
2023. 3. 21
카카오페이 #슬랙봇
5분 만에 배우는 일정 관리 슬랙봇 만드는 방법
2023. 3. 17
카카오페이 #Spring
Jackson Deserializer 코드 분석해보기
2023. 3. 9
카카오페이 #슬랙봇
슬랙봇 이모티콘 제작소 개발 그 뒷이야기!!
2023. 3. 3
카카오페이 #ifkakao2022
""if(kakao) 발표 어땠어요?"" 신선한 if(kakao) 인터뷰!
2023. 2. 9
카카오페이 #ifkakao2022
카카오페이 서버 개발자로 일한다는 것 (feat. 연진아 나 지금 되게 신나)
2023. 1. 27
카카오페이 #ifkakao2022
[if kakao 2022] Batch Performance를 고려한 최선의 Aggregation
2022. 12. 9
카카오페이 #ifkakao2022
[if kakao 2022] Batch Performance를 고려한 최선의 Reader
2022. 12. 9
카카오페이 #오픈소스
주니어 개발자의 오픈소스 활동 이야기
2022. 11. 3
카카오페이 #BE
WebFlux와 코루틴으로 BFF(Backend For Frontend) 구현하기
2022. 9. 26
카카오페이 #image processing server
이미지 처리를 위한 파이썬 서버 프레임워크 선정기 with Django, FastAPI, Sanic
2022. 8. 29
카카오페이 #Swagger
OpenAPI Specification을 이용한 더욱 효과적인 API 문서화
2022. 8. 22
카카오페이 #Onboarding
카카오페이 주니어 서버 개발자의 이모저모
2022. 7. 26
카카오페이 #BE
MSA 환경에서 네트워크 예외를 잘 다루는 방법
2022. 5. 25
카카오페이","https://surfit.io/link/1xQ2B
","결제탭 서버의UI(SDU) 방식을 설명하며안정적이고 유연한 구조로 결제탭의 다양한 콘텐츠를 효율적으로 서빙하는 결제탭은구조와 비동기호출을 활용해 사용자 맞춤형 혜택과 기능을 제공하며설정을 통해 각요소를 동적으로 관리한다. 카카오페이 클라이언트 실에서UI(이하 SDU) 라는 시스템을 통해 네이티브에 즉시적인변경을 반영할 수 있게 되었다. 결제탭 서버에서는 사용자 피드를 구성하기 위해 속성과 정책을 RowSetting이라는 정보로 DB에 저장하며 운영자가 필요에 맞게 어드민에서 설정을 즉시적으로 조정할 수 있다. 결제탭에서 사용된 연동되는 데이터와 Row의 관계에 대한 경우의 수는 다음과 같습니다 Row를 만들어 내고 클라이언트에게 RowType으로종류를 전달하기 때문에 RowProviderType을 사용하며 연동과 UI별로 구분된 타입들은 로직 실행 시 컴포넌트를 트리거하는 구분점으로 동작한다. 인터페이스구현체는인터페이스를 구현해야 하고 ResultProvider: ProviderMapper에서는 피드의 설정인 RowSetting에 해당하는 Provider를 매칭해 줍니다. ProviderType에 대한 구현체들이 모두 존재하는 걸 보장하기 위해단계에서 resultProviderCompoments가 모든 ProviterType를 가지는 지 확인하고 예외를 던져주지만 실수로 새로운 ProviderType만 추가한다면 애플리케이션시에 에러가 발생한다 ResultProvider에서는DI를 통해 ResultProvider를 주입받으므로 최종적으로 다음의 영역만이 새로운 기능 추가 시 변경된다. 캐시리소스 3중화 결제탭은 DB에 저장된정보를 기반으로 동작하기 때문에 장애 시에도 이 데이터를 안전하게 확보하는 것이 중요하며 Redis에 장애가 발생했을 때최소한 결제탭 서버만이라도 살아있다면 피드를 서빙할 수 있습니다 결제탭 서버는 다운되지 않은 이상앞서 언급한 여러 기법을 사용하여 안정성을 보장하고 있습니다 카카오페이에서 백엔드 개발을 하고 있는 해피입니다  법카카오페이 #코드 분석해보기
""if(kakao) 발표 어땠어요신선한 if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao) 인터뷰카카오페이 #""if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao)"" (연진아 나 지금 되게 신나)카카오페이 #""if(kakao)"" (카카오페이 #""if(kakao)"" "
"CSS의 :has() 가상 클래스 사용법
","HTML CSS JavaScript React GraphQL Python About CSS에서 자식이나 후손 요소는 아주 쉽게 선택할 수 있지만, 부모나 조상 요소를 선택하는 것은 불가능한 일이 었습니다. 그래서 오랫동안 자바스크립트를 동원해서 이러한 문제를 해결하곤 했었죠. 하지만 CSS에 :has() 가상 클래스가 추가되면서 이것도 이제 옛말이 되었습니다. 웹 개발자들이 많이 기다렸던 만큼 2023년 State of JS 설문 조사 가장 많이 채택된 기능으로 뽑히고도 했었죠.  이번 포스팅에서는 비교적 최근에 CSS에 추가된 기능인 :has() 가상 클래스를 어떻게 사용하는지 알아보도록 하겠습니다. 본 포스팅은 CSS 선택자(selector)와 대한 기본적인 이해가 필요합니다. 관련해서는 제가 별도 포스팅에서 다루고 있으니 참고하세요. 기본 문법 CSS의 :has() 가상 클래스는 결합자(combinator)처럼 기본적으로 2개의 선택자를 필요로 합니다. 첫 번째 선택자로 선택된 HTML 요소의 안에 두 번째 선택자로 선택이 가능한 HTML 요소가 있다면 첫 번째 선택자로 선택된 요소에 선언한 스타일이 적용됩니다. 네, 맞습니다. 두 번째 선택자가 아닌 첫 번째 선택자에 스타일에 적용됩니다. 이 점이 CSS의 결합자와의 가장 큰 차이점이며, 기존에 CSS로 할 수 없었던 부모나 조상 요소를 선택하는 것이 가능해진 결정적인 이유입니다. 예를 들어, 내부에 <a> 요소가 있는 <p> 요소를 선택하여 스타일하고 싶다면 다음과 같이 CSS를 작성할 수 있고요. 비활성화 된 <input> 요소가 있는 <form> 요소를 선택하여 스타일하고 싶다면 싶다면 다음과 같이 CSS를 작성할 수 있습니다. 조상 요소를 선택할 때 가장 많이 사용되지만, 엄밀히 얘기하면 :has() 가상 클래스의 활용 범위는 더 넓습니다. CSS 결합자에서 사용하는 >, +, ~ 기호를 잘 활용하면, 부모 요소, 하나의 이전 형제, 여러 이전 형제도 선택할 수 있습니다. 이 부분에 대해서는 뒤에서 좀 더 설명드리도록 하겠습니다. CSS 결합자에 대해서는 별도 포스팅에서 자세히 다루고 있으니 참고하세요. 조상 요소 선택 CSS에서 후손 요소를 선택하여 스타일하는 것은 아주 간단한 일입니다. 두 개의 선택자를 공백 문자로 연결해주면 첫 번째 선택자 안에서 두 번째 선택자와 부합하는 요소를 선택됩니다. 예를 들어, 다음과 같은 중첩된 상자가 있다고 가정해보겠습니다. out 클래스가 달린 요소 안에 있는 in 클래스가 달린 요소의 배경을 빨간색으로 칠하는 것은 쉽습니다. 그런데 반대로 in 클래스가 달린 요소의 밖에 있는 out 클래스가 달린 요소를 선택하여 스타일하려면 어떻게 해야할까요? 🤔 예전에 이런 작업은 자바스크립트가 없이는 거의 불가능했었는데요. 이제는 CSS :has() 가상 클래스가 있으니 쉽게 해결할 수 있습니다. CSS :has() 가상 클래스를 통해서 in 클래스가 달린 요소의 밖에 있는 out 클래스가 달린 요소의 배경을 초록색으로 칠해보겠습니다. 만약에 in 클래스가 달린 요소의 직계 부모 요소를 상대로만 제한하고 싶다면 > 기호를 사용하면 됩니다. 이전 요소 선택 CSS 결합자를 사용해서 다음 요소를 어렵지 않게 선택하여 스타일할 수 있습니다. 두 개의 선택자를 + 기호로 연결해주면 첫 번째 선택자 다음으로 나오는 요소가 두 번째 선택자와 부합하면 선택이 되죠. 예를 들어, 다음과 같은 중첩된 상자가 있다고 가정해보겠습니다. left 클래스가 달린 요소 다음에 오는 right 클래스가 달린 요소의 배경을 빨간색으로 칠해보겠습니다. 반대로 right 클래스가 달린 요소의 앞에 있는 left 클래스가 달린 요소를 선택하여 스타일하려면 어떻게 해야할까요? 🤔 마찬가지로 CSS :has() 가상 클래스를 이용하면 어렵지 않습니다. right 클래스가 달린 요소의 앞에 있는 left 클래스가 달린 요소의 배경을 초록색으로 칠해보겠습니다. + 기호 대신에 ~ 기호를 사용하면 바로 앞 뿐만 아니라 앞에 있는 모든 형제 요소를 선택할 수 있습니다. 자식 상태에 따른 부모 스타일 :has() 가상 클래스의 기본적인 사용법을 배웠으니 이 번에는 좀 더 재미있는 예제를 보여드릴까요? 자식 요소의 상태에 따라서 부모 요소의 스타일을 변경해줘야 할 때 :has() 가상 클래스가 특히 유용하게 사용될 수 있는데요. 예를 들어, 3개의 색깔 버튼을 감싸고 있는 상자가 있다고 가정해보겠습니다. 각 버튼을 누르고 있을 때 상자의 색깔이 이애 따라 바뀌게 하려면 어떻게 해야할까요? 부모 요소인 상자에 스타일을 적용해야 하니 :has() 가상 클래스를 사용해야할텐데요. 바로 :active 가상 클래스를 사용해서 자식 요소인 각 버튼이 활성화된 상태를 감지하면 되겠죠? 이 선택자를 :has() 가상 클래스의 인자로 넘겨주면 됩니다! 아래 웹 페이지에서 각 버튼을 누르고 계시면 상자의 배경색이 바뀌는 것을 보실 수 있으실 겁니다. 마치면서 지금까지 CSS에 추가된 :has() 가상 클래스 어떻게 사용하는지 실습을 통해서 함께 살펴보았습니다. :has() 가상 클래스는 부모 요소나 이전 요소를 선택할 수 있게 해주는 아주 유용한 기능입니다. 대부분의 모던 브라우저에서 지원되는 기능이니 실무에서 잘 활용하실 수 있으셨으면 좋겠습니다. This work is licensed under CC BY 4.0 github youtube twitter discord medium © 2016-2024 DaleSeo. All Rights Reserved.","https://surfit.io/link/vWD8l
",CSS의 :has() 가상 클래스는 결합자(combinator)처럼 기본적으로 2개의 선택자를 필요로하며 조상의 요소를 선택할 때 가장 많이 사용된다. 가상 클래스는 클래스가 달린 요소 안에 있는 클래스가 달린 요소의 배경을 빨간색으로 칠하는 것은 쉽습니다 부모 요소나 이전 요소를 선택할 수 있게 해주는 가상 클래스는 부모 요소나 이전 요소를 선택할 수 있게 해주는 아주 유용한 기능이다. 
